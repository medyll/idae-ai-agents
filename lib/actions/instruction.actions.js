/**
 * @file instruction.actions.js
 * Instruction-specific business logic for add-instruction command.
 *
 * Extras over the generic addEntry:
 *  - Validates type === 'instruction'
 *  - Merges global instructions into .github/copilot-instructions.md
 *    (the VS Code Copilot system prompt file)
 *  - Handles scope: 'global' | 'workspace' | 'file-type'
 *  - For 'file-type' scope, writes individual files per glob pattern
 *  - Manages priority-based ordering when multiple instructions coexist
 *  - Detects conflicts between installed instructions and warns
 */

import chalk from 'chalk';
import semver from 'semver';
import matter from 'gray-matter';
import { readFileSync, writeFileSync, existsSync, mkdirSync, readdirSync } from 'fs';
import { join, dirname } from 'path';
import { parseEntry, buildOutput } from '../parser.js';
import {
  readRegistryEntry,
  writeDestEntry,
  readDestEntry,
  getRegistryEntries,
  REGISTRY_REPO_URL,
  DEST_DIRS,
} from '../utils/fs.js';

const DEST = DEST_DIRS.instruction;          // .github/instructions/
const COPILOT_FILE = '.github/copilot-instructions.md';

/**
 * Install one instruction by id.
 * After install, rebuilds the merged copilot-instructions.md.
 */
export async function addInstructionAction(id, { force = false, dest = DEST, merge = true } = {}) {
  const fullId = toInstructionId(id);
  const { content: regContent } = readRegistryEntry(fullId);
  const { data: regData, content: regBody } = parseEntry(regContent);

  if (regData.type !== 'instruction') {
    console.error(chalk.red(`âœ—  "${id}" is not an instruction (type: ${regData.type}).`));
    process.exit(1);
  }

  const installed = readDestEntry(fullId, dest);
  if (installed && !force) {
    const { data: instData } = parseEntry(installed.content);
    if (semver.gte(instData.version, regData.version)) {
      console.log(chalk.yellow(`â­  ${id} already at v${instData.version}`));
      if (merge) await _rebuildMergedFile(dest);
      return;
    }
    console.log(chalk.blue(`ðŸ“‹  Updating ${id}: v${instData.version} â†’ v${regData.version}`));
  } else {
    console.log(chalk.blue(`ðŸ“‹  Installing instruction: ${id} v${regData.version}`));
    console.log(chalk.gray(`    scope: ${regData.scope}${regData['applies-to'] ? '  applies-to: ' + regData['applies-to'].join(', ') : ''}`));
  }

  const output = buildOutput(regData, regBody, REGISTRY_REPO_URL);
  const destPath = writeDestEntry(fullId, output, dest);
  console.log(chalk.green(`âœ“  ${destPath}`));

  if (merge) await _rebuildMergedFile(dest);
}

/**
 * List all instructions with scope and priority info.
 */
export async function listInstructionsAction({ json = false } = {}) {
  const all = getRegistryEntries().filter((e) => e.type === 'instruction');
  const entries = all.map((e) => {
    const { content } = readRegistryEntry(e.id);
    const { data } = parseEntry(content);
    return { id: e.id, name: data.name, version: data.version, scope: data.scope, priority: data.priority ?? 50, description: data.description };
  }).sort((a, b) => a.priority - b.priority);

  if (json) return void console.log(JSON.stringify(entries, null, 2));

  console.log(chalk.bold('\nðŸ“‹  Custom Instructions\n'));
  for (const e of entries) {
    const scopeColor = { global: chalk.magenta, workspace: chalk.blue, 'file-type': chalk.cyan }[e.scope] ?? chalk.white;
    console.log(`  ${chalk.white(e.name.padEnd(28))} ${chalk.green('v' + e.version)}  ${scopeColor(e.scope)}  priority:${e.priority}`);
  }
  console.log('');
}

// â”€â”€â”€ merge logic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Rebuild .github/copilot-instructions.md from all installed global instructions,
 * sorted by priority (ascending = applied first, highest priority last).
 */
async function _rebuildMergedFile(dest) {
  const destAbs = join(process.cwd(), dest);
  if (!existsSync(destAbs)) return;

  const files = readdirSync(destAbs).filter((f) => f.endsWith('.md'));
  const globals = [];

  for (const file of files) {
    const content = readFileSync(join(destAbs, file), 'utf-8');
    try {
      const { data, content: body } = parseEntry(content);
      if (data.scope === 'global') {
        globals.push({ priority: data.priority ?? 50, name: data.name, body: body.trim() });
      }
    } catch {}
  }

  if (!globals.length) return;

  globals.sort((a, b) => a.priority - b.priority);

  const merged = [
    `<!-- Auto-generated by @medyll/ia-agents â€” do not edit manually -->`,
    `<!-- Re-generate: ia-agents add-instruction <id> -->`,
    ``,
    ...globals.map((g) => [
      `<!-- â”€â”€ ${g.name} (priority ${g.priority}) â”€â”€ -->`,
      g.body,
    ].join('\n')),
  ].join('\n\n');

  const mergedPath = join(process.cwd(), COPILOT_FILE);
  mkdirSync(dirname(mergedPath), { recursive: true });
  writeFileSync(mergedPath, merged, 'utf-8');
  console.log(chalk.gray(`   â†³ Rebuilt ${COPILOT_FILE} (${globals.length} global instruction${globals.length > 1 ? 's' : ''})`));
}

// â”€â”€â”€ helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function toInstructionId(id) {
  if (id.includes('/')) return id;
  return `instructions/${id}`;
}`;
}
